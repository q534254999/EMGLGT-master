import math
import sys
# IMPORTING ALL THE NECESSERY PYSIDE2 MODULES FOR OUR APPLICATION.
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *

# MAINWINDOW CODE GENERATED BY THE QT DESIGNER AND pyside2-uic.
from settingDialogrun import *
# from emginterface import Ui_MainWindow
# import matplotlib
# from progressBar import *

# matplotlib.use("Qt5Agg")  # 声明使用QT5
# from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
# from matplotlib.figure import Figure
# from matplotlib import pyplot
import pyqtgraph as pg
import numpy as np
import qtawesome
import EMGPlot
from scipy import signal
from progressBar import *
from mainUI import Ui_MainWindow
from BluetoothHelper import BluetoothHelper

import threading
import time
# import pickle
# import pandas as pd
# import csv

import serial
import random
from collections import deque
# from tensorflow import keras
import binascii


SAMPLEFZ = 10
SAMPRATE = 10
DATASIZE = SAMPLEFZ * 60
PLOTSIZE = SAMPLEFZ * 9
MAXVALUE = 1000
WINSIZE = 0.1
WINSTEP = 0.25
THRESHOLD = 1E-3
SUBFRAMESIZE = 1
LINEWIDTH = 2
# 肌电传感器波特率
EMGBAUD = 9600
# 扩展传感器时请修改传感器数量和上下肢设备号
# 传感器数量按实际，上下肢设备号改成与传感器数量一致即可
SENSORNUM = 2
UPDOWNDEVICENO = 2
# 上下肢波特率
UPDOWNDEVICEBAUD = 115200
# 默认端口
DEFAULTCOM = "COM5"


class MySignal(QObject):
    label_msg = pyqtSignal(QLabel, str)
    pg_msg = pyqtSignal(pg.widgets.PlotWidget.PlotWidget, np.ndarray, int, str)
    probar_msg = pyqtSignal(int)
    # dbpg_msg = pyqtSignal(pg.widgets.PlotWidget.PlotWidget, list, list)
    db_trend_pg_msg = pyqtSignal(pg.widgets.PlotWidget.PlotWidget, list, list, int)
    cirbar_msg = pyqtSignal(int)


# 上下肢设备反馈信息解析读取
class InformationCollect(threading.Thread):

    def __init__(self):
        threading.Thread.__init__(self)
        # 上下肢角度反馈信息帧头
        self.FOOTANGLE = 'aaa804a41f'
        # 上下肢其余详细信息帧头
        self.INFORMATION = 'aaa835a63b'

        # 端口可选
        self.com = "COM7"
        # 波特率固定
        self.baud = 115200
        self.ser = None
        # 上下肢信息
        self.lgt = {'maxrace': 0, 'activespeed': 0, 'leftSymmetryData': 0, 'rightSymmetryData': 0,
                    'musculartensionD': 0, 'trainTimeSum': 0, 'passiveTrainTime': 0, 'activeTrainTime': 0,
                    'avgPower': 0, 'peakPower': 0, 'rightAngle': 0, 'spasmFlag': 0}
        # 读取标志位
        self.BOOL = True
        self.fatigueTime = None

    def set_com(self, com=DEFAULTCOM):
        # 端口，GNU / Linux上的/ dev / ttyUSB0 等 或 Windows上的 COM3 等
        self.com = com

    def set_baud(self, baud=115200):
        # 波特率，标准值之一：50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200
        self.baud = baud

    def get_lgtData(self):
        return self.lgt

    def run(self):
        # 循环接收数据
        time.sleep(3)
        while self.BOOL:
            if self.ser.in_waiting:
                STRGLO = self.ser.read(self.ser.in_waiting)
                # print(STRGLO)
                # 按数据帧分割
                streams = bytes(STRGLO).split(b'U')
                # print(streams)
                for value in streams:
                    if value:
                        # print(value)
                        # 转成16进制
                        value = binascii.b2a_hex(value)
                        # 转成字符串
                        value = value.decode('utf-8')
                        # print(value)
                        # 上下肢信息角度
                        if str.startswith(value, self.FOOTANGLE):
                            # print(value)
                            try:
                                rightAngele = int(value[10:14], 16)
                                # print(rightAngele)
                                self.lgt['rightAngle'] = rightAngele

                            except ValueError:
                                print("frame Error:")
                                print(value)

                        # 上下肢其余信息
                        # 详见LGT-5100产学研协议
                        elif str.startswith(value, self.INFORMATION) and len(value) > 110:
                            # print(value)
                            # print(value[10:14])
                            try:
                                # 数据段3
                                maxrace = int(value[10:14], 16)
                                spasmup = int(value[14:18], 16)
                                spasmdown = int(value[18:22], 16)
                                setupresis = int(value[22:26], 16)
                                setdownresis = int(value[26:30], 16)
                                activespeed = int(value[30:34], 16)
                                leftSymmetryData = int(value[34:38], 16)
                                rightSymmetryData = int(value[38:42], 16)
                                musculartensionD = int(value[42:46], 16)

                                # print(maxrace,spasmup,spasmdown,setupresis,setdownresis,activespeed,leftSymmetryData,rightSymmetryData,musculartensionD)
                                # print(maxrace)
                                self.lgt['maxrace'] = maxrace
                                self.lgt['activespeed'] = activespeed
                                self.lgt['leftSymmetryData'] = leftSymmetryData
                                self.lgt['rightSymmetryData'] = rightSymmetryData
                                self.lgt['musculartensionD'] = musculartensionD

                                # 数据段2
                                trainTimeSum = int(value[50:54], 16)
                                passiveTrainTime = int(value[54:58], 16)
                                activeTrainTime = int(value[58:62], 16)
                                trainMileSum = int(value[62:66], 16) * 0.1
                                passiveTrainMile = int(value[66:70], 16) * 0.1
                                activeTrainMile = int(value[70:74], 16) * 0.1
                                avgPower = int(value[74:78], 16)
                                peakPower = int(value[78:82], 16)
                                calorie = int(value[82:86], 16)
                                # print(trainTimeSum, passiveTrainTime, activeTrainTime, trainMileSum, passiveTrainMile,
                                #       activeTrainMile, avgPower, peakPower, calorie)

                                self.lgt['trainTimeSum'] = trainTimeSum
                                self.lgt['passiveTrainTime'] = passiveTrainTime
                                self.lgt['activeTrainTime'] = activeTrainTime
                                self.lgt['avgPower'] = avgPower
                                self.lgt['peakPower'] = peakPower

                                # 数据段1
                                joule = int(value[90:94], 16)
                                spasmFlag = int(value[94:96], 16)
                                heartVal = int(value[96:98], 16)
                                oximetry = int(value[98:100], 16)
                                pulse = int(value[100:102], 16)
                                startFlag = int(value[102:104], 16)
                                upDownFlag = int(value[104:106], 16)
                                defaultHealTime = int(value[106:110], 16)
                                frameNo = int(value[110:112], 16)
                                self.lgt['spasmFlag'] = spasmFlag

                            except ValueError:
                                print("frame Error:")
                                print(value)


    def DOpenPort(self, timeout):
        # 打开串口
        # 超时设置,None：永远等待操作，0为立即返回请求结果，其他值为等待超时时间(单位为秒）
        # print("上下肢串口打开")
        if self.ser is not None and self.ser.is_open:
            return True
        try:
            # 打开串口，并得到串口对象
            self.ser = serial.Serial(self.com, self.baud, timeout=timeout)
            # 判断是否打开成功
            if self.ser.is_open:
                return True
        except Exception as e:
            print("---异常---：", e)
        return False

    # 关闭串口
    def DColsePort(self):
        self.BOOL = False
        self.ser.close()

    # 写串口数据
    # 暂时没用到
    def DWritePort(self, text):
        if not self.ser.is_open:
            return -1
        result = self.ser.write(text.encode("gbk"))  # 写数据
        return result


# 肌电数据读取
class DataCollect(threading.Thread):
    ''' 测试代码'''
    '''
    def __init__(self):
        threading.Thread.__init__(self)
        self.res = deque(maxlen=DATASIZE)
        self.pos = 1
        print("DataCollect running1")

    def get_data(self):
        return list(self.res)

    def run(self):
        print("DataCollect running2")
        with open("2021_04_08_16-11-04_com3_data.csv") as f:
            reader = csv.reader(f)
            list1 = [row[0] for row in reader]
            list1 = list1[1:]
        while True:
            for data in list1:
                if self.pos % 20 == 0:
                    # self.res.clear()
                    time.sleep(2)
                self.res.append(float(data))
                self.pos += 1
    '''

    def __init__(self, dataNo):
        threading.Thread.__init__(self)
        # 肌电传感器序号
        self.dataNo = dataNo
        self.com = "COM5"
        self.baud = 9600
        self.ser = None
        self.dataQueue = deque(maxlen=20*DATASIZE)
        self.BOOL = True  # 读取标志位
        self.fatigueTime = None

    def set_com(self, com=DEFAULTCOM):
        # 端口，GNU / Linux上的/ dev / ttyUSB0 等 或 Windows上的 COM3 等
        self.com = com

    def set_baud(self, baud=9600):
        # 波特率，标准值之一：50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200
        self.baud = baud

    def get_data(self):
        return list(self.dataQueue)

    def run(self):
        # 循环接收数据
        time.sleep(3)
        while self.BOOL:
            if self.ser.in_waiting:
                STRGLO = self.ser.read(self.ser.in_waiting)
                streams = bytes(STRGLO).split(b'\r\n')
                for value in streams:
                    if value:
                        try:
                            self.dataQueue.append(float(value))
                        except ValueError:
                            print("EMG Collecting Value Error")

    # 打开串口
    def DOpenPort(self, timeout):
        # 超时设置,None：永远等待操作，0为立即返回请求结果，其他值为等待超时时间(单位为秒）
        # print("肌电串口打开")
        if self.ser is not None and self.ser.is_open:
            return True
        try:
            # 打开串口，并得到串口对象
            self.ser = serial.Serial(self.com, self.baud, timeout=timeout)
            # 判断是否打开成功
            if self.ser.is_open:
                return True
        except Exception as e:
            print("---异常---：", e)
        return False

    # 关闭串口
    def DColsePort(self):
        self.BOOL = False
        self.ser.close()

    # 写串口数据
    # 暂时用不到
    def DWritePort(self, text):
        if not self.ser.is_open:
            return -1
        result = self.ser.write(text.encode("gbk"))  # 写数据
        return result


class Model(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.start_time = time.time()
        self.index = 0
        # 是否开启蓝牙控制电刺激
        self.openbt = True
        # 是否usb连接上下肢设备
        self.openLGT_5100 = False
        # 是否采用蓝牙传输肌电信号（肌电信号与电刺激合用蓝牙传输）
        self.emgbt = True

        # self.mode = "DEBUG"
        self.mode = "RELEASE"
        # 采集数据包括SENSORNUM个肌电采集DataCollect和1个上下肢采集InformationCollect
        if self.openLGT_5100:
            self.collecting = [False] * (SENSORNUM+1)
        else:
            self.collecting = [False] * SENSORNUM
        # 保存数据只需保存肌电采集的数据
        self.recording = [False] * SENSORNUM
        self.Flag = True
        self.cmdType = 'None'
        self.conn = [DataCollect(i) for i in range(SENSORNUM)]
        if self.openLGT_5100:
            self.conn.append(InformationCollect())
        if self.mode == "DEBUG":
            self.data_file0 = "2021_04_23_18-17-54_COM6_data.npy"
            self.data0 = np.load(self.data_file0)
            self.data_file1 = "2021_04_23_18-17-55_COM5_data.npy"
            self.data1 = np.load(self.data_file1)

        # 开启蓝牙电刺激判断
        if self.openbt:
            self.bluetoothHelper = BluetoothHelper()
        else:
            self.bluetoothHelper = None

    def start_collect(self, dataNo, com=DEFAULTCOM, baud=115200):
        if self.collecting[dataNo]:
            self.stop_collect(dataNo)
            return True
        self.conn[dataNo].set_baud(baud)
        self.conn[dataNo].set_com(com)
        ret = self.conn[dataNo].DOpenPort(3)
        if ret:
            self.conn[dataNo].start()
            print("串口" + com + "开启")
            self.collecting[dataNo] = True
            return True
        else:
            print("串口" + com + "读取异常")
            self.collecting[dataNo] = False
            return False

    def stop_collect(self, dataNo):
        self.conn[dataNo].DColsePort()
        self.collecting[dataNo] = False

    def start_record(self, dataNo, com=DEFAULTCOM, baud=9600):
        if not self.recording[dataNo]:
            self.recording[dataNo] = True
            print('start recording...')
            data = self.get_data()
            save_time = time.strftime("%Y_%m_%d_%H-%M-%S", time.localtime())
            print(save_time)
            print(self.conn[dataNo].com)
            # print(data)
            path = 'D:/EMGData/' + save_time + '_' + str(self.conn[dataNo].com) + '_data.npy'
            path_fatigue_time = 'D:/EMGData/' + save_time + '_' + str(self.conn[dataNo].com) + '_time.npy'
            print(path)
            np.save(path, data)
            np.save(path_fatigue_time, self.conn.fatigueTime)
            print('save succeed')
            self.recording[dataNo] = False

    def get_data(self, dataNo):
        # if self.mode == "Debug":
        #     index = self.playback_index
        #     if len(self.playback_data) - index < DATASIZE:
        #         return self.playback_data[index:]
        #     self.playback_index += SAMPLEFZ // 5
        #     index = self.playback_index
        #     return self.playback_data[index:index + DATASIZE]
        # test
        # 如果上下肢设备连接了usb端口
        if self.openLGT_5100 and dataNo == UPDOWNDEVICENO:
            lgtData = self.conn[UPDOWNDEVICENO].get_lgtData()
            return lgtData
        else:
            if self.mode == "RELEASE":
                # Todo
                # 添加所有使用蓝牙集成的判断
                if self.emgbt:
                    return self.bluetoothHelper.getEMGData(self.emgbt)
                else:
                    if self.collecting is False:
                        return np.zeros(DATASIZE)
                    curdata = np.array(self.conn[dataNo].get_data())
                    return curdata

            elif self.mode == "DEBUG":
                # cur_time = time.time()
                # data_length = int(cur_time-self.start_time)*6
                data_length = self.index
                self.index += 1
                # data = pd.read_csv('2021_04_22_21-48-39_com3_data.csv')
                # data = data['data']
                if dataNo == 0:
                    return self.data0[:data_length]
                else:
                    return self.data1[:data_length]

    def get_filtered_signal_cross(self, data):
        emg = []
        if len(data) > 27:
            emg = (data[-PLOTSIZE:] - np.min(data[-PLOTSIZE:])) / (np.max(data[-PLOTSIZE:]) - np.min(data[-PLOTSIZE:]))
            b, a = signal.butter(8, 0.2, 'lowpass')
            emg = signal.filtfilt(b, a, emg)

        return emg if len(emg) > 0 else data

    def get_filtered_signal(self, data):
        emg = []
        if len(data) > 27:
            emg = (data - 0) / (1023 - 0)
            b, a = signal.butter(8, 0.2, 'lowpass')
            emg = signal.filtfilt(b, a, emg)

        return emg if len(emg) > 0 else data

    def get_trend(self, data):
        trend = []
        if len(data) > 0:
            trend.append(data[0])
            for i in range(len(data)):
                trend.append(trend[i]*0.99+data[i]*0.01)
        return trend if len(trend) > 0 else data

    def process_data(self, signals):
        # 处理数据获得结果
        values = [0, 0, 0, 0]
        stMaxs = []
        norm = np.zeros((1, 4))
        abs_y = np.zeros((1, 4))
        angle_y = np.zeros((1, 4))
        normalization_y = np.zeros((1, 4))
        normalization_half_y = np.zeros((1, 4))
        result = {}
        result['peak'] = [0,0,0,0]
        result['valley'] = [0,0,0,0]
        # 间隔周期
        result['peakInterval'] = [0,0,0,0]
        result['valleyInterval'] =[0,0,0,0]
        result['peakCycle'] = [0,0,0,0]
        result['valleyCycle'] = [0,0,0,0]
        # 计算各种指标
        result['signals_max'] = 0
        result['signals_min'] = 0
        result['signals_mean'] = 0
        result['signals_variance'] = 0

        result['fre_min'] = 0
        result['fre_max'] = 0
        result['fre_mean'] = 0

        result['spectralentropy'] = 0
        result['spectralflux'] = 0
        result['energyentropy'] = 0
        result['WAMP'] = 0
        # 均方根
        result['RMS'] = 0
        # 斜率变化率
        result['SSC'] = 0
        if len(signals) > 0:
            # # print(str(len(signals))+'-'+str(signals[0]))
            # winNum = int(len(signals) // (SAMPLEFZ * WINSIZE))
            # for i in range(winNum):
            #     stMax = np.max(signals[i * int(SAMPLEFZ * WINSIZE):(i + 1) * int(SAMPLEFZ * WINSIZE)])
            #     stMaxs.append(stMax)
            # # print(stMeans)
            #
            # # 全局平均值、最大值、最小值、标准差
            # values = [np.mean(signals), max(signals), min(signals), np.std(signals)]
            #
            # # 归一化
            # norm = [(i - values[2]) / (values[1] - values[0] + 1E-5) for i in signals]
            #
            # fft_signals = np.fft.fft(signals)
            #
            # n = len(signals)
            # x = np.arange(n)  # 频率个数
            # half_x = x[range(int(n / 2))]  # 取一半区间
            #
            # abs_y = np.abs(fft_signals)  # 取复数的绝对值，即复数的模(双边频谱)
            # angle_y = np.angle(fft_signals)  # 取复数的角度
            # normalization_y = abs_y / n  # 归一化处理（双边频谱）
            # # print(normalization_y.shape)
            # normalization_half_y = normalization_y[range(int(n / 2))]  # 由于对称性，只取一半区间（单边频谱）
            # 波峰波谷
            peakInd, valleyInd = EMGPlot.searchPeaks(signals)
            # print(peakInd)
            result['peak'] = signals[peakInd]
            result['valley'] = signals[valleyInd]
            # 间隔周期
            result['peakInterval'] = np.ediff1d(peakInd)
            result['valleyInterval'] = np.ediff1d(valleyInd)
            result['peakCycle'] = result['peakInterval'] / SAMPRATE
            result['valleyCycle'] = result['valleyInterval'] / SAMPRATE
            # 计算各种指标
            result['signals_max'] = min(EMGPlot.max_emg(signals), 1)
            result['signals_min'] = max(EMGPlot.min_emg(signals), 0)
            result['signals_mean'] = EMGPlot.mean_emg(signals)
            result['signals_variance'] = EMGPlot.variance(signals)

            result['fre_min'] = EMGPlot.frequence_min(signals)
            # result['fre_max'] = EMGPlot.frequence_max(signals)
            result['fre_mean'] = EMGPlot.frequence_avg(signals)

            result['spectralentropy'] = EMGPlot.SpectralEntropy(signals, SUBFRAMESIZE)
            result['spectralflux'] = EMGPlot.SpectralFlux(signals, SUBFRAMESIZE)
            result['energyentropy'] = EMGPlot.EnergyEntropy(signals, SUBFRAMESIZE)
            result['WAMP'] = EMGPlot.WAMP(signals, THRESHOLD)
            # 均方根
            result['RMS'] = EMGPlot.RMS(signals, SUBFRAMESIZE)
            # 斜率变化率
            result['SSC'] = EMGPlot.SSC(signals)
        # 肌电所有信息
        return result

    # 判断是否进行电刺激
    # spasmFlag 主被动标志 3：被动， 2：主动
    # TODO 修改电刺激函数
    def stimulusJudge(self, angle, signal_val, spasmFlag=3):
        if 25 <= angle <= 65 and spasmFlag == 3:
            return True
        if 25 <= angle <= 65 and signal_val < 400 and spasmFlag == 2:
            return True
        else:
            return False

    # 开启/暂停蓝牙
    # cmdType = 'start'
    # cmdType = 'pause'
    def setbluetooth(self, cmdType):
        self.cmdType = cmdType

    def run(self):
        while self.Flag:
            if self.cmdType == 'start':
                self.bluetoothHelper.sendCMD(1)  # 开始 or 重开
                self.cmdType = 'None'

            elif self.cmdType == 'pause':
                self.bluetoothHelper.sendCMD(3)  # 暂停
                self.cmdType = 'None'

            time.sleep(0.2)

    def stop(self):
        if self.bluetoothHelper:
            self.bluetoothHelper.stop()
        if self.emgbt:
            self.emgbt = False
        self.Flag = False


class Controller(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.models = Model()
        self.view = MainWindow()
        # 绑定按钮事件
        self.view.ui.openBtn_1.clicked.connect(self.startReadingDataA)
        self.view.ui.fatigueaBtn_1.clicked.connect(self.fatigueRecordA)
        self.view.ui.saveBtn_1.clicked.connect(self.startRecordingA)
        self.view.ui.openBtn_2.clicked.connect(self.startReadingDataB)
        self.view.ui.fatigueaBtn_2.clicked.connect(self.fatigueRecordB)
        self.view.ui.saveBtn_2.clicked.connect(self.startRecordingB)
        self.flag = False
        # 开启全屏
        self.view.showFullScreen()
        time.sleep(1)

    def stop(self):
        self.flag = False

    def startReadingDataA(self):
        if self.models.mode == "RELEASE":
            # 开始采集串口肌电信息
            if not self.models.collecting[0]:
                port = self.view.com1
                # print("com1:"+port)
                rt = self.models.start_collect(dataNo=0, com=port, baud=EMGBAUD)
            else:
                self.models.stop_collect(dataNo=0)

            if self.models.openLGT_5100:
                # 开始采集上下肢设备信息
                if not self.models.collecting[2]:
                    port = self.view.com3
                    # print("com3:" + port)
                    rt = self.models.start_collect(dataNo=2, com=port, baud=UPDOWNDEVICEBAUD)


    def startRecordingA(self):
        port = self.view.com1
        rt = self.models.start_record(dataNo=0, com=port)

    def fatigueRecordA(self):
        curtime = time.time()
        self.models.conn[0].fatigueTime = curtime
        print(curtime)

    def startReadingDataB(self):
        if not self.models.collecting[1]:
            port = self.view.com2
            # print("com2:" + port)
            rt = self.models.start_collect(dataNo=1, com=port, baud=EMGBAUD)
        else:
            self.models.stop_collect(dataNo=1)

        if self.models.openLGT_5100:
            # 开始采集上下肢设备信息
            if not self.models.collecting[2]:
                port = self.view.com3
                # print("com3:" + port)
                rt = self.models.start_collect(dataNo=2, com=port, baud=UPDOWNDEVICEBAUD)


    def startRecordingB(self):
        port = self.view.com2
        rt = self.models.start_record(dataNo=1, com=port)

    def fatigueRecordB(self):
        curtime = time.time()
        self.models.conn[1].fatigueTime = curtime
        print(curtime)

    def run(self):
        self.flag = True
        time.sleep(2)
        # 开启蓝牙
        if self.models.openbt:
            self.models.bluetoothHelper.Flag = True
            self.models.bluetoothHelper.start()
            self.models.start()
        lgtInformation = {}
        # 肌电传感器开启标志
        sensorStartFlag = [False] * SENSORNUM
        # startTime = time.time()
        t = 0
        # model = keras.models.load_model("./my_model")
        # self.view.showBoxValues(np.array((0, 0)))
        while self.flag:
            if self.view.isclosed:
                for i in range(3):
                    if self.models.collecting[i]:
                        self.models.stop_collect(i)
                self.models.stop()
                self.stop()
                break

            time.sleep(0.03)

            # 获取上下肢反馈数据
            if self.models.openLGT_5100:
                try:
                    # if not self.models.openLGT_5100:
                    lgtInformation = self.models.get_data(UPDOWNDEVICENO)
                    # print(lgtInformation)
                    self.view.showLabel(self.view.ui.max_pass_train_speed_val, lgtInformation['maxrace'])
                    self.view.showLabel(self.view.ui.real_time_speed_val, lgtInformation['activespeed'])
                    self.view.showLabel(self.view.ui.left_symmetry_val, lgtInformation['leftSymmetryData'])
                    self.view.showLabel(self.view.ui.right_symmetry_val, lgtInformation['rightSymmetryData'])
                    self.view.showLabel(self.view.ui.muscle_tension_val, lgtInformation['musculartensionD'])

                    self.view.showLabel(self.view.ui.train_time_val, lgtInformation['trainTimeSum'])
                    self.view.showLabel(self.view.ui.pass_train_time_val, lgtInformation['passiveTrainTime'])
                    self.view.showLabel(self.view.ui.active_train_time_val, lgtInformation['activeTrainTime'])
                    self.view.showLabel(self.view.ui.avg_power_val, lgtInformation['avgPower'])
                    self.view.showLabel(self.view.ui.peak_power_val, lgtInformation['peakPower'])

                    self.view.showLabel(self.view.ui.right_angle_val, lgtInformation['rightAngle'])
                    # 将信息更新到界面
                    self.view.showScene()

                except KeyError:
                    print("read lgt-5100 Error")

            # 获取每个传感器信息
            for sensor_i in range(SENSORNUM):
                # 滤波信号再滤波
                filter_signal = []
                # 对峰值信号滤波
                filter_peak = []
                filter_valley = []
                if self.models.emgbt:
                    self.models.collecting[sensor_i] = True

                newdata = self.models.get_data(sensor_i)

                if self.models.mode == 'DEBUG' or self.models.collecting[sensor_i]:
                    if len(newdata) > 0:

                        # 疲劳显示
                        # if t % 10 == 0:
                        #     curTime = time.time()
                        #     tt = int(curTime - startTime)
                        #     fatigue = random.randint(max(0, tt - random.randint(0, 60)),
                        #                              tt + random.randint(0, 60)) / random.randint(
                        #         25 * 60 - random.randint(0, 60), 25 * 60 + random.randint(0, 60))
                        #     fatigue = int(fatigue * 100)
                        #     self.view.showCirBar(fatigue)

                        # 肌电传感器1
                        if sensor_i == 0:
                            # 原始信号
                            self.view.showpg(self.view.originalsignal_plt, newdata[-PLOTSIZE:], sensor_i, 'red')
                            signals = self.models.get_filtered_signal(newdata)
                            signals_val = newdata[-1]
                            angle = 0
                            if self.models.openLGT_5100:
                                angle = (lgtInformation['rightAngle'] + 180) % 360
                            self.view.item_left.update_pram(angle, signals_val)
                            ElecData = newdata[-PLOTSIZE:]
                            # 检测是否改变了电刺激强度
                            if self.view.value_changed:
                                self.models.bluetoothHelper.setHealValue(self.view.value)
                                self.view.value_changed = False
                            if self.view.fre_changed:
                                self.models.bluetoothHelper.setHealFre(self.view.fre)
                                self.view.fre_changed = False
                            if self.view.bandwidth_changed:
                                self.models.bluetoothHelper.setHealBandwith(self.view.bandwidth)
                                self.view.bandwidth_changed = False
                            # 进行电刺激
                            # TODO 修改电刺激函数
                            if self.models.stimulusJudge(angle, signals_val):
                                t += 1
                                if not sensorStartFlag[sensor_i]:
                                    self.view.showpg(self.view.filtersignal_plt, ElecData, sensor_i, 'red')
                                    if self.models.bluetoothHelper:
                                        self.models.setbluetooth('start')
                                        sensorStartFlag[sensor_i] = True
                                        if t/50 > 1:
                                            self.models.bluetoothHelper.setHealValue(self.models.bluetoothHelper.bluetoothValue + 10)
                                            t /= 50
                            else:
                                if sensorStartFlag[sensor_i]:
                                    if self.models.bluetoothHelper:
                                        self.models.setbluetooth('pause')  # 暂停
                                        sensorStartFlag[sensor_i] = False
                            # signals_cross = self.models[i].get_filtered_signal_cross(newdata)
                            # signals_lr_list.append(signals_cross[-PLOTSIZE-20:-20])
                            if t % 100 == 0:
                                filter_signal = [signals, self.models.get_trend(signals)]
                                # t_start = time.time()
                                # 计算指标
                                # Todo
                                # 计算复杂度太高了，这周末优化一下呢？
                                result = self.models.process_data(signals)
                                # t_end = time.time()
                                # print("run time:"+str(t_end - t_start))
                                self.view.showLabel(self.view.ui.energy_entropy_val, result['energyentropy'])
                                self.view.showLabel(self.view.ui.pectral_entropy_val, result['spectralentropy'])

                                # if len(filter_signal) == 2:
                                #     self.view.showdb_trend_pg(self.view.filtersignal_plt, filter_signal,
                                #                               ['red', 'green'], LINEWIDTH)

                                # self.view.showLabel(self.view.ui.frequency_max_val, result['fre_max'])
                                # self.view.showLabel(self.view.ui.frequency_min_val, result['fre_min'])
                                self.view.showLabel(self.view.ui.average_val, result['fre_mean'])
                                self.view.showLabel(self.view.ui.gradient_val, result['SSC'])

                                # filter_peak.append(result['peak'])
                                # filter_peak.append(self.models[i].get_trend(result['peak']))
                                # filter_valley.append(result['valley'])
                                # filter_valley.append(self.models[i].get_trend(result['valley']))
                                # if len(filter_peak) == 2:
                                #     self.view.showdb_trend_pg(self.view.peaksignal_plt, filter_peak, ['red', 'green'],
                                #                               LINEWIDTH)
                                # if len(filter_valley) == 2:
                                #     self.view.showdb_trend_pg(self.view.valleysignal_plt, filter_valley,
                                #                               ['red', 'green'], LINEWIDTH)
                                self.view.showLabel(self.view.ui.signal_max_val, result['signals_max'])
                                self.view.showLabel(self.view.ui.signal_min_val, result['signals_min'])
                                # self.view.showLabel(self.view.ui.mean_val, result['signals_mean'])
                                # self.view.showLabel(self.view.ui.variance_val, result['signals_variance'])
                                # self.view.showLabel(self.view.ui.root_mean_square_val, result['RMS'])

                                # self.view.showpg(self.view.cyclesignal_plt, result['peakCycle'], i, 'red')
                                #
                                # self.view.showLabel(self.view.ui.cycle_val,
                                #                     0 if len(result['peakCycle']) < 1 else result['peakCycle'][-1])
                                # self.view.showLabel(self.view.ui.willson_val, result['WAMP'])
                                #
                                # self.view.showpg(self.view.intervalsignal_plt, result['peakInterval'], i, 'red')
                                # self.view.showLabel(self.view.ui.interval_val,
                                #                     0 if len(result['peakInterval']) < 1 else result['peakInterval'][
                                #                         -1])
                                # self.view.showLabel(self.view.ui.spectralflux_val, result['spectralflux'])

                        # 肌电传感器2 （目前只有2）
                        else:
                            # 原始信号
                            self.view.showpg(self.view.originalsignal_plt2, newdata[-PLOTSIZE:], sensor_i, 'blue')
                            signals = self.models.get_filtered_signal(newdata)
                            signals_val = newdata[-1]
                            angle = 0
                            if self.models.openLGT_5100:
                                angle = lgtInformation['rightAngle']
                            self.view.item_right.update_pram(angle, signals_val)

                            ElecData = newdata[-PLOTSIZE:]
                            # 进行电刺激
                            # 检测是否改变了电刺激强度
                            if self.view.value_changed:
                                self.models.bluetoothHelper.setHealValue(self.view.value)
                                self.view.value_changed = False
                            # TODO 修改电刺激函数
                            if self.models.stimulusJudge(angle, signals_val):
                                t += 1
                                print(t)
                                if not sensorStartFlag[sensor_i]:
                                    self.view.showpg(self.view.filtersignal_plt2, ElecData, sensor_i, 'red')
                                    if self.models.bluetoothHelper:
                                        self.models.setbluetooth('start')
                                        sensorStartFlag[sensor_i] = True
                                        if t/50 > 1:
                                            self.models.bluetoothHelper.setHealValue(self.models.bluetoothHelper.bluetoothValue + 10)
                                            t /= 50
                            else:
                                if sensorStartFlag[sensor_i]:
                                    if self.models.bluetoothHelper:
                                        self.models.setbluetooth('pause')  # 暂停
                                        sensorStartFlag[sensor_i] = False
                            # signals_cross = self.models[i].get_filtered_signal_cross(newdata)
                            # signals_lr_list.append(signals_cross[-PLOTSIZE - 20:-20])

                            if t % 100 == 0:
                                filter_signal = [signals, self.models.get_trend(signals)]
                                # 计算指标
                                # Todo
                                # 计算复杂度太高了，这周末优化一下呢？
                                result = self.models.process_data(signals)
                                self.view.showLabel(self.view.ui.energy_entropy_val2, result['energyentropy'])
                                self.view.showLabel(self.view.ui.pectral_entropy_val2, result['spectralentropy'])

                                # if len(filter_signal) == 2:
                                #     self.view.showdb_trend_pg(self.view.filtersignal_plt2, filter_signal,
                                #                               ['blue', 'deeppink'], LINEWIDTH)

                                # self.view.showLabel(self.view.ui.frequency_max_val2, result['fre_max'])
                                # self.view.showLabel(self.view.ui.frequency_min_val2, result['fre_min'])
                                self.view.showLabel(self.view.ui.average_val2, result['fre_mean'])
                                self.view.showLabel(self.view.ui.gradient_val2, result['SSC'])

                                # filter_peak.append(result['peak'])
                                # filter_peak.append(self.models[i].get_trend(result['peak']))
                                # filter_valley.append(result['valley'])
                                # filter_valley.append(self.models[i].get_trend(result['valley']))
                                # if len(filter_peak) == 2:
                                #     self.view.showdb_trend_pg(self.view.peaksignal_plt2, filter_peak,
                                #                               ['blue', 'deeppink'], LINEWIDTH)
                                # if len(filter_valley) == 2:
                                #     self.view.showdb_trend_pg(self.view.valleysignal_plt2, filter_valley,
                                #                               ['blue', 'deeppink'], LINEWIDTH)
                                self.view.showLabel(self.view.ui.signal_max_val2, result['signals_max'])
                                self.view.showLabel(self.view.ui.signal_min_val2, result['signals_min'])
                                # self.view.showLabel(self.view.ui.mean_val2, result['signals_mean'])
                                # self.view.showLabel(self.view.ui.variance_val2, result['signals_variance'])
                                # self.view.showLabel(self.view.ui.root_mean_square_val2, result['RMS'])
                                #
                                # self.view.showpg(self.view.cyclesignal_plt2, result['peakCycle'], i, 'blue')
                                # self.view.showLabel(self.view.ui.cycle_val2,
                                #                     0 if len(result['peakCycle']) < 1 else result['peakCycle'][-1])
                                # self.view.showLabel(self.view.ui.willson_val2, result['WAMP'])
                                #
                                # self.view.showpg(self.view.intervalsignal_plt2, result['peakInterval'], i, 'blue')
                                # self.view.showLabel(self.view.ui.interval_val2,
                                #                     0 if len(result['peakInterval']) < 1 else result['peakInterval'][
                                #                         -1])
                                # self.view.showLabel(self.view.ui.spectralflux_val2, result['spectralflux'])


class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.isclosed = False
        # 电刺激强度
        self.value = 50
        # 电刺激频率
        self.fre = 50
        # 电刺激脉宽
        self.bandwidth = 100
        # 电刺激强度是否改变
        self.value_changed = False
        # 电刺激频率是否改变
        self.fre_changed = False
        # 电刺激脉宽是否改变
        self.bandwidth_changed = False
        self.setWindowTitle("上下肢肌电智能优化康复系统")
        # self.setWindowFlag(QtCore.Qt.FramelessWindowHint)   # 隐藏边框
        self.color_dic = {"red": "r", "blue": 'b', 'green': '#008000', 'yellow': 'y', 'chocolate': '#D2691E', 'deeppink': '#FF1493'}
        # 添加logo
        self.logo = QtWidgets.QPushButton(QIcon("./logo.png"), " ")
        self.logo.setGeometry(QtCore.QRect(30, 90, 120, 120))
        self.logo.setIconSize(QtCore.QSize(120, 120))
        self.logo.setObjectName('logo')
        self.title = QtWidgets.QLabel("上下肢肌电智能优化康复系统")
        self.title.setObjectName('title')
        # self.ui.topWidget.setMaximumHeight(120)
        # self.ui.topLayout.addWidget(self.title)
        # # self.ui.topLayout.addWidget(self.logo, 0, 4, 1, 1)
        # self.ui.topWidget.setStyleSheet('''
        #     *{background-color:#ececec;}
        #     QLabel{
        #     text-align:center;
        #     color:#4169E1;
        #     border:none;
        #     font-weight:600;
        #     font-size:48px;
        #     font-family:'微软雅黑';
        #      }
        #     QPushButton{
        #     border:none;
        #     font-weight:600;
        #     font-size:16px;
        #     font-family:'微软雅黑';
        #      }
        #     ''')
        self.title.setAlignment(Qt.AlignCenter)
        # self.logo.setStyleSheet('''
        #     QPushButton{ text-align:right;padding-right:30px;color:#808080;font-size:14px;}
        #     ''')

        # 旋转动画左
        self.scene_left = QtWidgets.QGraphicsScene(0, 0, 100, 100)
        self.ui.gear_left.setScene(self.scene_left)
        self.ui.gear_left.setSceneRect(0, 0, 100, 100)
        self.ui.gear_left.setRenderHint(QPainter.Antialiasing)
        self.ui.gear_left.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        self.item_left = boxItem()
        # self.item.setPos(0, 0)
        self.scene_left.addItem(self.item_left)

        # 旋转动画右
        self.scene_right = QtWidgets.QGraphicsScene(0, 0, 100, 100)
        self.ui.gear_right.setScene(self.scene_right)
        self.ui.gear_right.setSceneRect(0, 0, 100, 100)
        self.ui.gear_right.setRenderHint(QPainter.Antialiasing)
        self.ui.gear_right.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        self.item_right = boxItem()
        self.scene_right.addItem(self.item_right)

        # 电刺激强度调节
        self.ui.comboBox_value.activated.connect(self.selectionChangeValue)
        # 电刺激频率调节
        self.ui.comboBox_fre.activated.connect(self.selectionChangeFre)
        # 电刺激脉宽调节
        self.ui.comboBox_bandwidth.activated.connect(self.selectionChangeBandwidth)

        self.setting_dialog = None
        self.com1 = 'com1'
        self.com2 = 'com1'
        self.com3 = 'com1'
        self.persent = 0
        # 用pyqtgraph画图
        pg.setConfigOptions(antialias=True)  # 启用抗锯齿选项
        pg.setConfigOption('background', '#ECECEC')
        # 串口1
        # 原始信号
        self.ui.originalsignal.setMaximumSize(QSize(560, 195))
        self.originalsignal_FigLayout = QGridLayout(self.ui.originalsignal)
        self.originalsignal_plt = pg.PlotWidget(title='原始信号')
        self.originalsignal_plt.setYRange(0, 1000)
        self.originalsignal_plt.setXRange(0, PLOTSIZE)
        self.originalsignal_plt.showGrid(x=True, y=True)
        self.originalsignal_FigLayout.addWidget(self.originalsignal_plt, 0, 0, 1, 1)
        # 滤波信号
        self.ui.filtersignal.setMaximumSize(QSize(560, 195))
        self.filtersignal_FigLayout = QGridLayout(self.ui.filtersignal)
        self.filtersignal_plt = pg.PlotWidget(title='电刺激信号')
        self.filtersignal_plt.setYRange(0, 1000)
        self.filtersignal_plt.setXRange(0, PLOTSIZE)
        self.filtersignal_plt.showGrid(x=True, y=True)
        self.filtersignal_FigLayout.addWidget(self.filtersignal_plt)
    #     # 波峰谷信号
    #     self.ui.peakvalleysignal.setMaximumSize(QSize(600, 170))
    #     self.peakvalleysignal_FigLayout = QGridLayout(self.ui.peakvalleysignal)
    #     self.peaksignal_plt = pg.PlotWidget(title='波峰信号')
    #     self.peaksignal_plt.setYRange(0, 1)
    #     self.peaksignal_plt.setXRange(0, 500)
    #     self.peaksignal_plt.showGrid(x=True, y=True)
    #     self.valleysignal_plt = pg.PlotWidget(title='波谷信号')
    #     self.valleysignal_plt.setYRange(0, 1)
    #     self.valleysignal_plt.setXRange(0, 500)
    #     self.valleysignal_plt.showGrid(x=True, y=True)
    #     self.peakvalleysignal_FigLayout.addWidget(self.peaksignal_plt, 0, 0)
    #     self.peakvalleysignal_FigLayout.addWidget(self.valleysignal_plt, 0, 1)
    #     # 周期间隔信号
    #     self.ui.cycleintervalsignal.setMaximumSize(QSize(600, 170))
    #     self.cycleintervalsignal_FigLayout = QGridLayout(self.ui.cycleintervalsignal)
    #     self.cyclesignal_plt = pg.PlotWidget(title='周期信号')
    #     self.cyclesignal_plt.setYRange(0, 10)
    #     self.cyclesignal_plt.setXRange(0, 500)
    #     self.cyclesignal_plt.showGrid(x=True, y=True)
    #     self.intervalsignal_plt = pg.PlotWidget(title='间隔信号')
    #     self.intervalsignal_plt.setYRange(0, 100)
    #     self.intervalsignal_plt.setXRange(0, 500)
    #     self.intervalsignal_plt.showGrid(x=True, y=True)
    #     self.cycleintervalsignal_FigLayout.addWidget(self.cyclesignal_plt, 0, 0)
    #     self.cycleintervalsignal_FigLayout.addWidget(self.intervalsignal_plt, 0, 1)
    #
    #
        # 串口2
        # 原始信号
        self.ui.originalsignal2.setMaximumSize(QSize(560, 195))
        self.originalsignal_FigLayout2 = QGridLayout(self.ui.originalsignal2)
        self.originalsignal_plt2 = pg.PlotWidget(title='原始信号')
        self.originalsignal_plt2.setYRange(0, 1000)
        self.originalsignal_plt2.setXRange(0, PLOTSIZE)
        self.originalsignal_plt2.showGrid(x=True, y=True)
        self.originalsignal_FigLayout2.addWidget(self.originalsignal_plt2, 0, 0, 1, 1)
        # 滤波信号
        self.ui.filtersignal2.setMaximumSize(QSize(560, 195))
        self.filtersignal_FigLayout2 = QGridLayout(self.ui.filtersignal2)
        self.filtersignal_plt2 = pg.PlotWidget(title='电刺激信号')
        self.filtersignal_plt2.setYRange(0, 1000)
        self.filtersignal_plt2.setXRange(0, PLOTSIZE)
        self.filtersignal_plt2.showGrid(x=True, y=True)
        self.filtersignal_FigLayout2.addWidget(self.filtersignal_plt2)
    #     # 波峰谷信号
    #     self.ui.peakvalleysignal2.setMaximumSize(QSize(600, 170))
    #     self.peakvalleysignal_FigLayout2 = QGridLayout(self.ui.peakvalleysignal2)
    #     self.peaksignal_plt2 = pg.PlotWidget(title='波峰信号')
    #     self.peaksignal_plt2.setYRange(0, 1)
    #     self.peaksignal_plt2.setXRange(0, 500)
    #     self.peaksignal_plt2.showGrid(x=True, y=True)
    #     self.valleysignal_plt2 = pg.PlotWidget(title='波谷信号', font_size=1)
    #     self.valleysignal_plt2.setYRange(0, 1)
    #     self.valleysignal_plt2.setXRange(0, 500)
    #     self.valleysignal_plt2.showGrid(x=True, y=True)
    #     self.peakvalleysignal_FigLayout2.addWidget(self.peaksignal_plt2, 0, 0)
    #     self.peakvalleysignal_FigLayout2.addWidget(self.valleysignal_plt2, 0, 1)
    #     # 周期间隔信号
    #     self.ui.cycleintervalsignal2.setMaximumSize(QSize(600, 170))
    #     self.cycleintervalsignal_FigLayout2 = QGridLayout(self.ui.cycleintervalsignal2)
    #     self.cyclesignal_plt2 = pg.PlotWidget(title='周期信号')
    #     self.cyclesignal_plt2.setYRange(0, 10)
    #     self.cyclesignal_plt2.setXRange(0, 500)
    #     self.cyclesignal_plt2.showGrid(x=True, y=True)
    #     self.intervalsignal_plt2 = pg.PlotWidget(title='间隔信号')
    #     self.intervalsignal_plt2.setYRange(0, 100)
    #     self.intervalsignal_plt2.setXRange(0, 500)
    #     self.intervalsignal_plt2.showGrid(x=True, y=True)
    #     self.cycleintervalsignal_FigLayout2.addWidget(self.cyclesignal_plt2, 0, 0)
    #     self.cycleintervalsignal_FigLayout2.addWidget(self.intervalsignal_plt2, 0, 1)
    #
    #     # bottomwidget
    #     self.ui.fusesignalWidget.setMaximumSize(QSize(600, 170))
    #     self.fusesignal_FigLayout = QGridLayout(self.ui.fusesignal)
    #     self.fusesignal_plt = pg.PlotWidget(title='左右肢融合信号')
    #     self.fusesignal_plt.setYRange(0, 1)
    #     self.fusesignal_plt.setXRange(0, PLOTSIZE)
    #     self.fusesignal_plt.showGrid(x=True, y=True)
    #     self.fusesignal_FigLayout.addWidget(self.fusesignal_plt)
    #
    #     # cirbar
    #     self.CirBarItem = CirBar()
    #     self.ui.cirBarWidgetLayout.addWidget(self.CirBarItem)
    #

        self.ms = MySignal()
        self.ms.label_msg.connect(self.drawLabel)
        self.ms.pg_msg.connect(self.drawpg)
        # self.ms.dbpg_msg.connect(self.drawdbpg)
        # self.ms.probar_msg.connect(self.drawprobar)
        self.ms.db_trend_pg_msg.connect(self.drawdb_trend_pg)
        # self.ms.cirbar_msg.connect(self.drawCirBar)
    #
    #     # 鼠标中键移动窗口
    #     self.m_flag = False
    #
    # def mousePressEvent(self, event):
    #     if event.button() == Qt.MiddleButton:
    #         self.m_flag = True
    #         self.m_Position = event.globalPos() - self.pos()  # 获取鼠标相对窗口的位置
    #         event.accept()
    #         self.setCursor(QCursor(Qt.OpenHandCursor))  # 更改鼠标图标
    #
    # def mouseMoveEvent(self, event):
    #     if Qt.LeftButton and self.m_flag:
    #         self.move(event.globalPos() - self.m_Position)  # 更改窗口位置
    #         event.accept()
    #
    # def mouseReleaseEvent(self, QMouseEvent):
    #     self.m_flag = False
    #     self.setCursor(QCursor(Qt.ArrowCursor))
    #

    # 右键连接菜单事件
    def contextMenuEvent(self, evt):
        menu = QMenu(self)
        # 示例
        # open_recent_menu = QMenu(menu)
        # open_recent_menu.setTitle("最近最打开")

        setting_action = QAction(qtawesome.icon('fa.cog', color='#808080'), "设置", menu)
        setting_action.triggered.connect(self.open_settingDialog)

        help_action = QAction(qtawesome.icon('fa.info-circle', color='#808080'), "帮助", menu)
        help_action.triggered.connect(lambda: print("help"))

        exit_action = QAction(qtawesome.icon('fa.sign-out', color='#808080'), "退出", menu)
        exit_action.triggered.connect(self.close)

        menu.addAction(setting_action)
        menu.addAction(help_action)

        menu.addSeparator()
        menu.addAction(exit_action)
        menu.exec_(evt.globalPos())

    def closeEvent(self, a0: QtGui.QCloseEvent) -> None:
        self.isclosed = True
        print('exit')

    def open_settingDialog(self):
        if self.setting_dialog:
            self.setting_dialog.show()
        else:
            self.setting_dialog = SettingDialog()
            self.setting_dialog.show()
        self.setting_dialog._comlist.connect(self.get_comlist)

    def get_comlist(self, parameter1, parameter2, parameter3):
        # print("test get comlist")
        # print("parameter1", parameter1)
        # print("parameter2", parameter2)
        # print("parameter3", parameter3)
        self.com1 = parameter1
        self.com2 = parameter2
        self.com3 = parameter3
        self.persent = 50

    # 电刺激下拉框改变触发事件
    def selectionChangeValue(self, value):
        self.value_changed = True
        self.value = value

    def selectionChangeFre(self, fre):
        self.fre_changed = True
        self.fre = fre

    def selectionChangeBandwidth(self, bandwidth):
        self.bandwidth_changed = True
        self.bandwidth = bandwidth

    # def drawprobar(self, num):
    #     self.persent = num

    def drawLabel(self, lb, info):
        lb.setText(info)

    # def drawCirBar(self, val):
    #     self.CirBarItem.GenUpdate(val)
    #
    def drawpg(self, plt, vals, sensorNo, color):
        if sensorNo == 0:
            plt.plot(clear=True).setData(vals, pen=self.color_dic[color])
        else:
            plt.plot(clear=True).setData(vals, pen=self.color_dic[color])

    # def drawdbpg(self, plt, vals_list, colors):
    #     plt.plot(clear=True).setData(np.array(vals_list[0]), pen=self.color_dic[colors[0]])
    #     plt.plot().setData(np.array(vals_list[1]), pen=self.color_dic[colors[1]])

    def drawdb_trend_pg(self, plt, vals_list, colors, width=2):
        plt.plot(clear=True).setData(np.array(vals_list[0]), pen=self.color_dic[colors[0]])
        plt.plot().setData(np.array(vals_list[1]), pen=pg.mkPen(self.color_dic[colors[1]], width=width))

    def showdb_trend_pg(self, plt, vals_list, colors, width):
        self.ms.db_trend_pg_msg.emit(plt, vals_list, colors, width)

    # def showdbpg(self, plt, vals_list, colors):
    #     self.ms.dbpg_msg.emit(plt, vals_list, colors)

    def showpg(self, plt, vals, sensorNo, color):
        self.ms.pg_msg.emit(plt, np.array(vals), sensorNo, color)

    def showLabel(self, obj, data):
        data = round(data, 3)
        self.ms.label_msg.emit(obj, str(data))

    # def showprobar(self, num):
    #     self.ms.probar_msg.emit(num)
    #
    # def showCirBar(self, val):
    #     self.ms.cirbar_msg.emit(val)

    def showScene(self):
        self.item_left.update()
        self.item_right.update()


# 旋转动画&电刺激动画
class boxItem(QGraphicsItem):
    def __init__(self):
        super(boxItem, self).__init__()
        self.angle = 0
        self.radian = 0
        self.color_red = QColor(255, 0, 0)
        self.color_white = QColor(255, 255, 255)
        self.color = QColor(255, 255, 255)
        self.scale_light = 5

        # 初始矩形线
        self.rectLines = [QPointF(0, 0), QPointF(0, -50), QPointF(5, -50), QPointF(5, 0)]
        # 旋转矩形线
        self.rotLines = [QPointF(50, 50), QPointF(50, 0), QPointF(55, 0), QPointF(55, 50)]
        # 电刺激闪电线
        self.lightLines = [QPointF(2.72, 0.33), QPointF(4.23, 1.14), QPointF(2.9, 2), QPointF(3.28, 2.26),
                           QPointF(2.1, 3.04), QPointF(2.4, 3.26), QPointF(0.4, 4.6), QPointF(1.58, 2.87),
                           QPointF(1.3, 2.67), QPointF(2.2, 1.73), QPointF(1.95, 1.53)]

        # 缩放
        for i in self.lightLines:
            i *= self.scale_light
            i.setX(i.x()+100)

    def boundingRect(self):
        return QRectF(0, -300, 300, 300)

    def update_pram(self, angle, signal_val):
        # angle: 上下肢设备反馈的右下肢角度
        self.angle = angle
        # print(angle)
        # print(signal_val)
        self.radian = self.angle * math.pi/180
        self.rotLines = []
        ct, st = math.cos(self.radian), math.sin(self.radian)
        for p in self.rectLines:
            p = QPointF(50+p.x()*ct-p.y()*st, 50+p.x()*st+p.y()*ct)
            self.rotLines.append(p)
        if 25 <= angle <= 65:
            self.color = self.color_red
        else:
            self.color = self.color_white

    def draw_circle(self, painter):
        painter.drawEllipse(QPoint(50, 50), 25, 25)

    def draw_trunk(self, painter):
        for i in range(1, len(self.rotLines)):
            painter.drawLine(self.rotLines[i-1], self.rotLines[i])
        painter.drawLine(self.rotLines[0], self.rotLines[-1])
        painter.background()

    def draw_bling_bling(self, painter):
        brush = QBrush(Qt.SolidPattern)
        # brush.setColor(QColor(255,0,0))
        brush.setColor(QColor(self.color))
        painter.setBrush(brush)
        painter.setPen(QColor(self.color))
        # painter.drawEllipse(QPointF(100, 0), 5, 5)
        p = QPolygonF(self.lightLines)
        painter.drawPolygon(p)

        # for i in range(1, len(self.lightLines)):
        #     painter.drawLine(self.lightLines[i - 1], self.lightLines[i])
        # painter.drawLine(self.lightLines[0], self.lightLines[-1])

    def paint(self, painter, option, widget=None):
        self.draw_circle(painter)
        self.draw_trunk(painter)
        self.draw_bling_bling(painter)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    logi = Controller()
    logi.start()
    sys.exit(app.exec_())

